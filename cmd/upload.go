package cmd

import (
	"fmt"
	"io"
	"log"
	"os"
	"strings"

	"archive/tar"
	"compress/gzip"
	"io/ioutil"
	"path/filepath"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

// Get a temporary file for our
func getTempFile() *os.File {
	tmpfile, err := ioutil.TempFile("/tmp", "rsdoc-upload-")
	if err != nil {
		panic(err)
	}
	return tmpfile
}

func cleanUpTempfile(f *os.File, keep bool) string {
	// Close and rename file if we're going to keep it
	if keep {
		f.Close()
		parts := []string{f.Name(), ".tar.gz"}
		new_name := strings.Join(parts, "")
		os.Rename(f.Name(), new_name)
		return new_name

	} else {
		// Otherwise just remove it
		os.Remove(f.Name())
		return f.Name()
	}
}

// uploadCmd represents the upload command
var uploadCmd = &cobra.Command{
	Use:   "upload",
	Short: "Upload new or updated documentation",
	Long:  ``,
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("Uploading docs...")

		// Gather all of the options
		verbose, _ := cmd.Flags().GetBool("verbose")
		all, _ := cmd.Flags().GetBool("all")
		keep, _ := cmd.Flags().GetBool("keep")
		path := viper.GetString("docpath")
		version := viper.GetString("version")
		token := viper.GetString("token")

		files, err := get_files(args[0], all)
		if err != nil {
			panic(err)
		}

		if verbose {
			fmt.Println(files)
		}

		// Create our tar.gz file
		file := getTempFile()
		defer cleanUpTempfile(file, keep)

		// set up the gzip writer
		gw := gzip.NewWriter(file)
		defer gw.Close()
		tw := tar.NewWriter(gw)
		defer tw.Close()

		// add each file as needed into the current tar archive
		for i := range files {
			if err := addFile(tw, files[i]); err != nil {
				log.Fatalln(err)
			}
		}

		// Upload our tar.gz
		message, err := send_files(path, version, token)

		if err != nil {
			panic(err)
		}

		fmt.Println(message)
	},
}

func addFile(tw *tar.Writer, path string) error {
	file, err := os.Open(path)
	if err != nil {
		return err
	}
	defer file.Close()
	if stat, err := file.Stat(); err == nil {
		// now lets create the header as needed for this file within the tarball
		header := new(tar.Header)
		header.Name = path
		header.Size = stat.Size()
		header.Mode = int64(stat.Mode())
		header.ModTime = stat.ModTime()
		// write the header to the tarball archive
		if err := tw.WriteHeader(header); err != nil {
			return err
		}
		// copy the file data to the tarball
		if _, err := io.Copy(tw, file); err != nil {
			return err
		}
	}
	return nil
}

// Find which files we're uploading
func get_files(dirpath string, all bool) (matches []string, err error) {

	err = filepath.Walk(dirpath, func(path string, info os.FileInfo, err error) error {
		// If all is chosen, tar up everything no matter the extension
		// otherwise we assume the directory is using our Hugo theme and we
		// then only want to include the unique files for the site and not
		// a ton of duplicated files
		if all == true {
			matches = append(matches, path)
		} else {

			// Skip the revealjs directory
			if strings.Contains(path, "revealjs/") {
				return nil
			}

			ext := filepath.Ext(path)

			if ext == ".html" || ext == ".xml" || ext == ".json" {
				matches = append(matches, path)
			}
		}
		return nil
	})

	return matches, err
}

// FIXME send the tar file to the server eventually
func send_files(path string, version string, token string) (message string, err error) {
	message = fmt.Sprintf("Options: %s %s %s", path, version, token)
	return message, nil
}

func init() {
	RootCmd.AddCommand(uploadCmd)

	// By default we only send *.json, *.html, and *.xml files and
	// rely on our hosted assets in CloudFront. However, we need to be
	// able to support docs generated by systems OTHER than our Hugo theme.
	// Things like Sphinx, Jekyll, etc. This flag will upload all files.
	uploadCmd.Flags().BoolP("all", "a", false, "Upload all files")
	uploadCmd.Flags().BoolP("keep", "k", false, "Keep tar file after upload")

}
